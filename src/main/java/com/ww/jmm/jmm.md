# Java内存模型

## JMM模型描述

### 现代计算机内存模型

![640](img\640.webp)

为了解决cpu、内存速度不匹配问题，引入高速缓存，同时也会为计算机系统增加复杂度，引入`缓存一致性`问题。

### JMM

![640-1](img\640-1.webp)

所有共享变量都存储于主内存，这里变量指实例变量和类变量，不包含局部变量，因为局部变量是线程私有的。

每个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。

`线程对变量的所有操作（读，写）都必须在工作内存中完成，而不能直接操作主内存中的变量。`

`不同线程之间不能直接访问对方工作内存中的变量，线程间变量的值传递是需要通过主内存中转来完成的。`

JMM关键技术点都是围绕着多线程的原子性、可见性和有序性建立的；

* 原子性

* 可见性

* 有序性

  有序性问题的原因是因为程序在执行时，可能会进行指令重排，重排后的指令与原指令的顺序未必一致。

  之所以需要做指令重排，就是**为了尽量少的中断流水线，提高性能**

## volatile

volatile写操作是在前面和后面分别插入内存屏障，而volatile读操作是在后边插入两个内存屏障。

### 写

![640-2](img\640-2.webp)

### 读

![640-3](img\640-3.webp)

## Happen-Before规则

如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。



不允许指令重排

* 程序顺序原则：一个线程内保证语义的串行性；
* volatile规则：volatile变量的写，先发生于读，这保证了volatile变量的可见性；
* 锁规则：解锁（unlock）必然发生在随后的加锁（lock）前；
* 传递性：A先于B，B先于C，那么A必然先于C；
* 线程的start()方法先于它的每一个动作；
* 线程的所有操作先于线程的终结（Thread.join()）；
* 线程的中断（interrupt()）先于被中断线程的代码；
* 对象的构造方法执行、结束先于finalize()方法；